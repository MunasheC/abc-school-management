package com.bank.schoolmanagement.service;

import com.bank.schoolmanagement.context.SchoolContext;
import com.bank.schoolmanagement.entity.Payment;
import com.bank.schoolmanagement.entity.School;
import com.bank.schoolmanagement.entity.Student;
import com.bank.schoolmanagement.entity.StudentFeeRecord;
import com.bank.schoolmanagement.repository.PaymentRepository;
import com.bank.schoolmanagement.repository.StudentFeeRecordRepository;
import com.bank.schoolmanagement.repository.StudentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Payment Service - Business logic for payment transactions
 * 
 * LEARNING: Service layer for financial transactions
 * - Records payments from various methods (cash, mobile money, bank transfer)
 * - Links payments to students and fee records
 * - Provides audit trail for all transactions
 * - Supports payment reversal (refunds, errors)
 * - Integrates with bank systems via transaction references
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final PaymentRepository paymentRepository;
    private final StudentRepository studentRepository;
    private final StudentFeeRecordRepository feeRecordRepository;
    private final StudentFeeRecordService feeRecordService;
    private final AuditTrailService auditTrailService;

    /**
     * Record a payment
     * 
     * LEARNING: Transaction processing
     * This method:
     * 1. Creates payment record
     * 2. Updates student's fee record (adds payment)
     * 3. Both happen in one transaction - either both succeed or both fail
     * 
     * @Transactional ensures data consistency
     */
    @Transactional
    public Payment recordPayment(Long studentId, Payment payment) {
        log.info("Recording payment of {} for student ID: {}", payment.getAmount(), studentId);
        
        // Get student
        Student student = studentRepository.findById(studentId)
                .orElseThrow(() -> {
                    log.error("Student not found with ID: {}", studentId);
                    return new IllegalArgumentException("Student not found with ID: " + studentId);
                });
        
        // Set student relationship
        payment.setStudent(student);
        
        // Get student's latest fee record
        Optional<StudentFeeRecord> feeRecordOpt = feeRecordService.getLatestFeeRecordForStudent(studentId);
        if (feeRecordOpt.isPresent()) {
            StudentFeeRecord feeRecord = feeRecordOpt.get();
            payment.setFeeRecord(feeRecord);
            
            // Update fee record with payment amount
            feeRecord.addPayment(payment.getAmount());
            feeRecordRepository.save(feeRecord);
            log.info("Fee record updated, new outstanding: {}", feeRecord.getOutstandingBalance());
        } else {
            log.warn("No fee record found for student {}, payment recorded but no balance updated", studentId);
        }
        
        // Save payment (paymentReference will be auto-generated by @PrePersist)
        Payment savedPayment = paymentRepository.save(payment);
        log.info("Payment recorded with reference: {}", savedPayment.getPaymentReference());
        
        // Audit trail
        auditTrailService.logAction(
            null,
            savedPayment.getReceivedBy() != null ? savedPayment.getReceivedBy() : "SYSTEM",
            "RECORD_PAYMENT",
            "Payment",
            savedPayment.getId() != null ? savedPayment.getId().toString() : null,
            String.format("Payment of %s recorded for student ID %s (Ref: %s, Method: %s)",
                savedPayment.getAmount(), studentId, savedPayment.getPaymentReference(), 
                savedPayment.getPaymentMethod() != null ? savedPayment.getPaymentMethod().name() : "UNKNOWN")
        );
        
        return savedPayment;
    }

    /**
     * Record payment with transaction reference
     * 
     * LEARNING: Bank integration
     * When payment comes from mobile banking or internet banking,
     * we store the bank's transaction reference for reconciliation
     */
    @Transactional
    public Payment recordPaymentWithTransaction(Long studentId, Payment payment, String transactionReference) {
        log.info("Recording payment with transaction reference: {}", transactionReference);
        payment.setTransactionReference(transactionReference);
        return recordPayment(studentId, payment);
    }

    /**
     * Get payment by ID
     */
    public Optional<Payment> getPaymentById(Long id) {
        log.debug("Fetching payment with ID: {}", id);
        return paymentRepository.findById(id);
    }

    /**
     * Get payment by payment reference
     */
    public Optional<Payment> getPaymentByReference(String paymentReference) {
        log.debug("Fetching payment with reference: {}", paymentReference);
        return paymentRepository.findByPaymentReference(paymentReference);
    }

    /**
     * Get payment by transaction reference
     * 
     * LEARNING: Bank reconciliation
     * Used to find a payment by the bank's transaction ID
     * Helps reconcile payments from different channels
     */
    public Optional<Payment> getPaymentByTransactionReference(String transactionReference) {
        log.debug("Fetching payment with transaction reference: {}", transactionReference);
        return paymentRepository.findByTransactionReference(transactionReference);
    }

    /**
     * Get all payments for a student
     */
    public List<Payment> getPaymentsByStudent(Long studentId) {
        log.debug("Fetching payments for student ID: {}", studentId);
        return paymentRepository.findByStudentId(studentId);
    }

    /**
     * Get active (not reversed) payments for a student
     */
    public List<Payment> getActivePaymentsByStudent(Long studentId) {
        log.debug("Fetching active payments for student ID: {}", studentId);
        return paymentRepository.findActivePaymentsByStudentId(studentId);
    }

    /**
     * Get payments by payment method
     */
    public List<Payment> getPaymentsByMethod(String paymentMethod) {
        log.debug("Fetching payments by method: {}", paymentMethod);
        return paymentRepository.findByPaymentMethod(paymentMethod);
    }

    /**
     * Get payments by status
     */
    public List<Payment> getPaymentsByStatus(String status) {
        log.debug("Fetching payments with status: {}", status);
        return paymentRepository.findByStatus(status);
    }

    /**
     * Get reversed payments (audit trail)
     */
    public List<Payment> getReversedPayments() {
        log.debug("Fetching reversed payments");
        return paymentRepository.findByIsReversedTrue();
    }

    /**
     * Get payments in date range
     */
    public List<Payment> getPaymentsBetweenDates(LocalDateTime startDate, LocalDateTime endDate) {
        log.debug("Fetching payments between {} and {}", startDate, endDate);
        return paymentRepository.findPaymentsBetweenDates(startDate, endDate);
    }

    /**
     * Get recent payments
     */
    public List<Payment> getRecentPayments(LocalDateTime since) {
        log.debug("Fetching recent payments since: {}", since);
        return paymentRepository.findRecentPayments(since);
    }

    /**
     * Get payments received by specific bursar
     */
    public List<Payment> getPaymentsByReceivedBy(String receivedBy) {
        log.debug("Fetching payments received by: {}", receivedBy);
        return paymentRepository.findByReceivedBy(receivedBy);
    }

    /**
     * Reverse a payment
     * 
     * LEARNING: Payment reversal
     * Used for:
     * - Refunds
     * - Incorrect amount entered
     * - Payment errors
     * 
     * This doesn't delete the payment (audit trail)
     * It marks it as reversed and subtracts from fee record
     */
    @Transactional
    public Payment reversePayment(Long paymentId, String reason) {
        log.warn("Reversing payment ID: {}, Reason: {}", paymentId, reason);
        
        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> {
                    log.error("Payment not found with ID: {}", paymentId);
                    return new IllegalArgumentException("Payment not found with ID: " + paymentId);
                });
        
        if (payment.getIsReversed()) {
            log.error("Payment {} already reversed", paymentId);
            throw new IllegalStateException("Payment already reversed");
        }
        
        // Mark payment as reversed
        payment.reverse(reason);
        
        // Update fee record - subtract the payment amount
        if (payment.getFeeRecord() != null) {
            StudentFeeRecord feeRecord = payment.getFeeRecord();
            feeRecord.addPayment(payment.getAmount().negate()); // Negative amount = subtract
            feeRecordRepository.save(feeRecord);
            log.info("Fee record updated after reversal, new outstanding: {}", feeRecord.getOutstandingBalance());
        }
        
        Payment savedPayment = paymentRepository.save(payment);
        log.info("Payment reversed successfully");
        
        // Audit trail
        auditTrailService.logAction(
            null,
            "SYSTEM",
            "REVERSE_PAYMENT",
            "Payment",
            savedPayment.getId().toString(),
            String.format("Reversed payment of %s for student ID %s (Ref: %s, Reason: %s)",
                savedPayment.getAmount(), 
                savedPayment.getStudent() != null ? savedPayment.getStudent().getId() : "UNKNOWN",
                savedPayment.getPaymentReference(), reason)
        );
        
        return savedPayment;
    }

    /**
     * Reverse payment by reference
     */
    @Transactional
    public Payment reversePaymentByReference(String paymentReference, String reason) {
        log.warn("Reversing payment with reference: {}, Reason: {}", paymentReference, reason);
        
        Payment payment = paymentRepository.findByPaymentReference(paymentReference)
                .orElseThrow(() -> {
                    log.error("Payment not found with reference: {}", paymentReference);
                    return new IllegalArgumentException("Payment not found with reference: " + paymentReference);
                });
        
        return reversePayment(payment.getId(), reason);
    }

    // ========== FINANCIAL REPORTS ==========

    /**
     * Calculate total payments by student
     */
    public BigDecimal calculateTotalByStudent(Long studentId) {
        log.debug("Calculating total payments for student ID: {}", studentId);
        BigDecimal total = paymentRepository.calculateTotalPaymentsByStudent(studentId);
        log.info("Total payments for student {}: {}", studentId, total);
        return total;
    }

    /**
     * Calculate total by payment method
     * 
     * LEARNING: Payment method analysis
     * Shows which payment channels are most used
     * Helps bank understand customer preferences
     */
    public BigDecimal calculateTotalByMethod(String paymentMethod) {
        log.debug("Calculating total for payment method: {}", paymentMethod);
        BigDecimal total = paymentRepository.calculateTotalByPaymentMethod(paymentMethod);
        log.info("Total for method {}: {}", paymentMethod, total);
        return total;
    }

    /**
     * Calculate total in date range
     */
    public BigDecimal calculateTotalInDateRange(LocalDateTime startDate, LocalDateTime endDate) {
        log.debug("Calculating total between {} and {}", startDate, endDate);
        BigDecimal total = paymentRepository.calculateTotalInDateRange(startDate, endDate);
        log.info("Total in date range: {}", total);
        return total;
    }

    /**
     * Count payments by method
     */
    public long countByMethod(String paymentMethod) {
        log.debug("Counting payments by method: {}", paymentMethod);
        return paymentRepository.countByPaymentMethod(paymentMethod);
    }

    /**
     * Get today's payments
     */
    public List<Payment> getTodaysPayments() {
        LocalDateTime startOfDay = LocalDateTime.now().toLocalDate().atStartOfDay();
        log.debug("Fetching today's payments since: {}", startOfDay);
        return paymentRepository.findRecentPayments(startOfDay);
    }

    /**
     * Get this week's payments
     */
    public List<Payment> getThisWeeksPayments() {
        LocalDateTime weekAgo = LocalDateTime.now().minusWeeks(1);
        log.debug("Fetching this week's payments since: {}", weekAgo);
        return paymentRepository.findRecentPayments(weekAgo);
    }

    /**
     * Get payment statistics by method
     * 
     * LEARNING: Business intelligence
     * Returns summary of payments by each method
     * Useful for the bank to understand channel usage
     */
    public PaymentStatistics getPaymentStatistics() {
        log.debug("Generating payment statistics");
        
        PaymentStatistics stats = new PaymentStatistics();
        
        // Count by method
        stats.setCashCount(countByMethod("CASH"));
        stats.setMobileMoneyCount(countByMethod("MOBILE_MONEY"));
        stats.setBankTransferCount(countByMethod("BANK_TRANSFER"));
        stats.setChequeCount(countByMethod("CHEQUE"));
        stats.setCardCount(countByMethod("CARD"));
        
        // Total by method
        stats.setCashTotal(calculateTotalByMethod("CASH"));
        stats.setMobileMoneyTotal(calculateTotalByMethod("MOBILE_MONEY"));
        stats.setBankTransferTotal(calculateTotalByMethod("BANK_TRANSFER"));
        stats.setChequeTotal(calculateTotalByMethod("CHEQUE"));
        stats.setCardTotal(calculateTotalByMethod("CARD"));
        
        log.info("Payment statistics generated");
        return stats;
    }

    /**
     * Inner class for payment statistics
     */
    public static class PaymentStatistics {
        private long cashCount;
        private long mobileMoneyCount;
        private long bankTransferCount;
        private long chequeCount;
        private long cardCount;
        
        private BigDecimal cashTotal = BigDecimal.ZERO;
        private BigDecimal mobileMoneyTotal = BigDecimal.ZERO;
        private BigDecimal bankTransferTotal = BigDecimal.ZERO;
        private BigDecimal chequeTotal = BigDecimal.ZERO;
        private BigDecimal cardTotal = BigDecimal.ZERO;
        
        // Getters and setters
        public long getCashCount() { return cashCount; }
        public void setCashCount(long cashCount) { this.cashCount = cashCount; }
        
        public long getMobileMoneyCount() { return mobileMoneyCount; }
        public void setMobileMoneyCount(long mobileMoneyCount) { this.mobileMoneyCount = mobileMoneyCount; }
        
        public long getBankTransferCount() { return bankTransferCount; }
        public void setBankTransferCount(long bankTransferCount) { this.bankTransferCount = bankTransferCount; }
        
        public long getChequeCount() { return chequeCount; }
        public void setChequeCount(long chequeCount) { this.chequeCount = chequeCount; }
        
        public long getCardCount() { return cardCount; }
        public void setCardCount(long cardCount) { this.cardCount = cardCount; }
        
        public BigDecimal getCashTotal() { return cashTotal; }
        public void setCashTotal(BigDecimal cashTotal) { this.cashTotal = cashTotal; }
        
        public BigDecimal getMobileMoneyTotal() { return mobileMoneyTotal; }
        public void setMobileMoneyTotal(BigDecimal mobileMoneyTotal) { this.mobileMoneyTotal = mobileMoneyTotal; }
        
        public BigDecimal getBankTransferTotal() { return bankTransferTotal; }
        public void setBankTransferTotal(BigDecimal bankTransferTotal) { this.bankTransferTotal = bankTransferTotal; }
        
        public BigDecimal getChequeTotal() { return chequeTotal; }
        public void setChequeTotal(BigDecimal chequeTotal) { this.chequeTotal = chequeTotal; }
        
        public BigDecimal getCardTotal() { return cardTotal; }
        public void setCardTotal(BigDecimal cardTotal) { this.cardTotal = cardTotal; }
        
        public long getTotalCount() {
            return cashCount + mobileMoneyCount + bankTransferCount + chequeCount + cardCount;
        }
        
        public BigDecimal getGrandTotal() {
            return cashTotal.add(mobileMoneyTotal).add(bankTransferTotal).add(chequeTotal).add(cardTotal);
        }
    }

    // ========== MULTI-TENANT SCHOOL-AWARE METHODS ==========

    /**
     * Get all payments for current school
     */
    public List<Payment> getAllPaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching all payments for school: {}", currentSchool.getSchoolName());
        return paymentRepository.findBySchool(currentSchool);
    }

    /**
     * Get payment by ID for current school with security validation
     */
    public Optional<Payment> getPaymentByIdForCurrentSchool(Long id) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching payment {} for school: {}", id, currentSchool.getSchoolName());
        
        return paymentRepository.findById(id)
                .filter(payment -> {
                    SchoolContext.validateSchoolAccess(payment.getSchool());
                    return true;
                });
    }

    /**
     * Get payment by reference for current school
     */
    public Optional<Payment> getPaymentByReferenceForCurrentSchool(String paymentReference) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching payment reference {} for school: {}", paymentReference, currentSchool.getSchoolName());
        return paymentRepository.findBySchoolAndPaymentReference(currentSchool, paymentReference);
    }

    /**
     * Get payments by method for current school
     */
    public List<Payment> getPaymentsByMethodForCurrentSchool(String paymentMethod) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching {} payments for school: {}", paymentMethod, currentSchool.getSchoolName());
        return paymentRepository.findBySchoolAndPaymentMethod(currentSchool, paymentMethod);
    }

    /**
     * Get payments by status for current school
     */
    public List<Payment> getPaymentsByStatusForCurrentSchool(String status) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching {} payments for school: {}", status, currentSchool.getSchoolName());
        return paymentRepository.findBySchoolAndStatus(currentSchool, status);
    }

    /**
     * Get payments in date range for current school
     */
    public List<Payment> getPaymentsBetweenDatesForCurrentSchool(LocalDateTime startDate, LocalDateTime endDate) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching payments between {} and {} for school: {}", 
                 startDate, endDate, currentSchool.getSchoolName());
        return paymentRepository.findBySchoolAndDateRange(currentSchool, startDate, endDate);
    }

    /**
     * Get today's payments for current school
     */
    public List<Payment> getTodaysPaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        LocalDateTime startOfDay = LocalDateTime.now().toLocalDate().atStartOfDay();
        log.debug("Fetching today's payments for school: {}", currentSchool.getSchoolName());
        return paymentRepository.findRecentPaymentsBySchool(currentSchool, startOfDay);
    }

    /**
     * Get this week's payments for current school
     */
    public List<Payment> getThisWeeksPaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        LocalDateTime weekAgo = LocalDateTime.now().minusWeeks(1);
        log.debug("Fetching this week's payments for school: {}", currentSchool.getSchoolName());
        return paymentRepository.findRecentPaymentsBySchool(currentSchool, weekAgo);
    }

    /**
     * Get active (not reversed) payments for current school
     */
    public List<Payment> getActivePaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching active payments for school: {}", currentSchool.getSchoolName());
        // Get all payments and filter for completed, non-reversed
        return paymentRepository.findBySchool(currentSchool).stream()
                .filter(p -> !p.getIsReversed() && "COMPLETED".equals(p.getStatus()))
                .collect(java.util.stream.Collectors.toList());
    }

    /**
     * Get reversed payments for current school (audit trail)
     */
    public List<Payment> getReversedPaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Fetching reversed payments for school: {}", currentSchool.getSchoolName());
        return paymentRepository.findBySchoolAndIsReversedTrue(currentSchool);
    }

    /**
     * Calculate total payments for current school
     */
    public BigDecimal calculateTotalPaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Calculating total payments for school: {}", currentSchool.getSchoolName());
        BigDecimal total = paymentRepository.calculateTotalPaymentsBySchool(currentSchool);
        log.info("Total payments for {}: {}", currentSchool.getSchoolName(), total);
        return total != null ? total : BigDecimal.ZERO;
    }

    /**
     * Calculate total by payment method for current school
     */
    public BigDecimal calculateTotalByMethodForCurrentSchool(String paymentMethod) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Calculating {} total for school: {}", paymentMethod, currentSchool.getSchoolName());
        BigDecimal total = paymentRepository.calculateTotalBySchoolAndMethod(currentSchool, paymentMethod);
        log.info("{} total for {}: {}", paymentMethod, currentSchool.getSchoolName(), total);
        return total != null ? total : BigDecimal.ZERO;
    }

    /**
     * Calculate total in date range for current school
     */
    public BigDecimal calculateTotalInDateRangeForCurrentSchool(LocalDateTime startDate, LocalDateTime endDate) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Calculating total between {} and {} for school: {}", 
                 startDate, endDate, currentSchool.getSchoolName());
        BigDecimal total = paymentRepository.calculateTotalInDateRangeBySchool(currentSchool, startDate, endDate);
        log.info("Total for {} in date range: {}", currentSchool.getSchoolName(), total);
        return total != null ? total : BigDecimal.ZERO;
    }

    /**
     * Calculate daily revenue for current school
     */
    public BigDecimal calculateDailyRevenueForCurrentSchool(LocalDateTime date) {
        School currentSchool = SchoolContext.getCurrentSchool();
        LocalDateTime startOfDay = date.toLocalDate().atStartOfDay();
        LocalDateTime endOfDay = startOfDay.plusDays(1);
        log.debug("Calculating daily revenue for {} on {}", currentSchool.getSchoolName(), date.toLocalDate());
        
        BigDecimal revenue = paymentRepository.calculateTotalInDateRangeBySchool(currentSchool, startOfDay, endOfDay);
        log.info("Daily revenue for {}: {}", currentSchool.getSchoolName(), revenue);
        return revenue != null ? revenue : BigDecimal.ZERO;
    }

    /**
     * Count payments by method for current school
     */
    public long countByMethodForCurrentSchool(String paymentMethod) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Counting {} payments for school: {}", paymentMethod, currentSchool.getSchoolName());
        return paymentRepository.countBySchoolAndPaymentMethod(currentSchool, paymentMethod);
    }

    /**
     * Count total payments for current school
     */
    public long countPaymentsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Counting total payments for school: {}", currentSchool.getSchoolName());
        return paymentRepository.countBySchool(currentSchool);
    }

    /**
     * Record payment for current school
     * Automatically assigns school from context
     */
    @Transactional
    public Payment recordPaymentForCurrentSchool(Long studentId, Payment payment) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.info("Recording payment of {} for student {} in school: {}", 
                 payment.getAmount(), studentId, currentSchool.getSchoolName());
        
        // Get student and validate school ownership
        Student student = studentRepository.findById(studentId)
                .orElseThrow(() -> {
                    log.error("Student not found with ID: {}", studentId);
                    return new IllegalArgumentException("Student not found with ID: " + studentId);
                });
        
        SchoolContext.validateSchoolAccess(student.getSchool());
        
        // Auto-assign school
        payment.setSchool(currentSchool);
        payment.setStudent(student);
        
        // Get student's latest fee record and validate school
        Optional<StudentFeeRecord> feeRecordOpt = feeRecordService.getLatestFeeRecordForStudent(studentId);
        if (feeRecordOpt.isPresent()) {
            StudentFeeRecord feeRecord = feeRecordOpt.get();
            SchoolContext.validateSchoolAccess(feeRecord.getSchool());
            
            payment.setFeeRecord(feeRecord);
            feeRecord.addPayment(payment.getAmount());
            feeRecordRepository.save(feeRecord);
            log.info("Fee record updated, new outstanding: {}", feeRecord.getOutstandingBalance());
        } else {
            log.warn("No fee record found for student {}", studentId);
        }
        
        Payment savedPayment = paymentRepository.save(payment);
        log.info("Payment recorded with reference: {}", savedPayment.getPaymentReference());
        
        return savedPayment;
    }

    /**
     * Record payment with transaction reference for current school
     */
    @Transactional
    public Payment recordPaymentWithTransactionForCurrentSchool(
            Long studentId, Payment payment, String transactionReference) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.info("Recording payment with transaction {} for school: {}", 
                 transactionReference, currentSchool.getSchoolName());
        payment.setTransactionReference(transactionReference);
        return recordPaymentForCurrentSchool(studentId, payment);
    }

    /**
     * Reverse payment for current school with security validation
     */
    @Transactional
    public Payment reversePaymentForCurrentSchool(Long paymentId, String reason) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.warn("Reversing payment {} in school: {}, Reason: {}", 
                 paymentId, currentSchool.getSchoolName(), reason);
        
        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> {
                    log.error("Payment not found with ID: {}", paymentId);
                    return new IllegalArgumentException("Payment not found with ID: " + paymentId);
                });
        
        // Security validation
        SchoolContext.validateSchoolAccess(payment.getSchool());
        
        if (payment.getIsReversed()) {
            log.error("Payment {} already reversed", paymentId);
            throw new IllegalStateException("Payment already reversed");
        }
        
        // Mark payment as reversed
        payment.reverse(reason);
        
        // Update fee record
        if (payment.getFeeRecord() != null) {
            StudentFeeRecord feeRecord = payment.getFeeRecord();
            SchoolContext.validateSchoolAccess(feeRecord.getSchool());
            
            feeRecord.addPayment(payment.getAmount().negate());
            feeRecordRepository.save(feeRecord);
            log.info("Fee record updated after reversal, new outstanding: {}", feeRecord.getOutstandingBalance());
        }
        
        Payment savedPayment = paymentRepository.save(payment);
        log.info("Payment reversed successfully");
        
        return savedPayment;
    }

    /**
     * Reverse payment by reference for current school
     */
    @Transactional
    public Payment reversePaymentByReferenceForCurrentSchool(String paymentReference, String reason) {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.warn("Reversing payment {} in school: {}, Reason: {}", 
                 paymentReference, currentSchool.getSchoolName(), reason);
        
        Payment payment = paymentRepository.findBySchoolAndPaymentReference(currentSchool, paymentReference)
                .orElseThrow(() -> {
                    log.error("Payment not found with reference: {}", paymentReference);
                    return new IllegalArgumentException("Payment not found with reference: " + paymentReference);
                });
        
        return reversePaymentForCurrentSchool(payment.getId(), reason);
    }

    /**
     * Get payment statistics for current school
     */
    public PaymentStatistics getPaymentStatisticsForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Generating payment statistics for school: {}", currentSchool.getSchoolName());
        
        PaymentStatistics stats = new PaymentStatistics();
        
        // Count by method
        stats.setCashCount(countByMethodForCurrentSchool("CASH"));
        stats.setMobileMoneyCount(countByMethodForCurrentSchool("MOBILE_MONEY"));
        stats.setBankTransferCount(countByMethodForCurrentSchool("BANK_TRANSFER"));
        stats.setChequeCount(countByMethodForCurrentSchool("CHEQUE"));
        stats.setCardCount(countByMethodForCurrentSchool("CARD"));
        
        // Total by method
        stats.setCashTotal(calculateTotalByMethodForCurrentSchool("CASH"));
        stats.setMobileMoneyTotal(calculateTotalByMethodForCurrentSchool("MOBILE_MONEY"));
        stats.setBankTransferTotal(calculateTotalByMethodForCurrentSchool("BANK_TRANSFER"));
        stats.setChequeTotal(calculateTotalByMethodForCurrentSchool("CHEQUE"));
        stats.setCardTotal(calculateTotalByMethodForCurrentSchool("CARD"));
        
        log.info("Payment statistics generated for school: {}", currentSchool.getSchoolName());
        return stats;
    }

    /**
     * Get payment breakdown by method for current school
     * Returns map of payment method -> total amount
     */
    public java.util.Map<String, BigDecimal> getPaymentBreakdownForCurrentSchool() {
        School currentSchool = SchoolContext.getCurrentSchool();
        log.debug("Generating payment breakdown for school: {}", currentSchool.getSchoolName());
        
        java.util.Map<String, BigDecimal> breakdown = new java.util.HashMap<>();
        breakdown.put("CASH", calculateTotalByMethodForCurrentSchool("CASH"));
        breakdown.put("MOBILE_MONEY", calculateTotalByMethodForCurrentSchool("MOBILE_MONEY"));
        breakdown.put("BANK_TRANSFER", calculateTotalByMethodForCurrentSchool("BANK_TRANSFER"));
        breakdown.put("CHEQUE", calculateTotalByMethodForCurrentSchool("CHEQUE"));
        breakdown.put("CARD", calculateTotalByMethodForCurrentSchool("CARD"));
        
        log.info("Payment breakdown generated for school: {}", currentSchool.getSchoolName());
        return breakdown;
    }
}
